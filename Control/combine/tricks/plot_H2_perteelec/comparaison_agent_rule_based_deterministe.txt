from buffer_tools.rule_based import rule_based_actions


from discrete_BCQ import utils
import gym
import numpy as np
import matplotlib
matplotlib.use("TkAgg")
import matplotlib.pyplot as plt
from discrete_BCQ.DQN import DQN
from discrete_BCQ.discrete_BCQ import discrete_BCQ
from buffer_tools.hash_manager import Dim_manager
from scipy.interpolate import make_interp_spline, BSpline

regular_parameters = {  # multi_env
    "nb_parents": 2,
    "euclidian_dist": 4,
    # Exploration
    ### Modifié pour l'abaisser dans les épisodes en low noise
    "start_timesteps": 8760,  # nombre de step avant de ne plus prendre que des actions aléatoires
    "initial_eps": 0.01,
    "end_eps": 0.1,
    "eps_decay_period": 1,
    # Evaluation
    # "eval_freq": 8759,#Attention c'est en nombre de step et pas en nombre d'épisodes
    "eval_freq": 8760,
    "eval_eps": 0.005,
    # Learning
    "discount": 0.9,
    "buffer_size": 1e6,
    "batch_size": 256,
    "optimizer": "Adam",
    "optimizer_parameters": {
        "lr": 1e-8
    },
    "train_freq": 1,
    "polyak_target_update": False,
    "target_update_freq": 70000,
    # tau passé de 0.005 à 0.9
    "tau": 0.005
}

manager = Dim_manager(4, 2)
manager._dim([3., 2.])
dim = manager.dim

from microgrid.envs.import_data import Import_data

import_data = Import_data(mode='train')
consumption_norm, consumption, production_norm, production = import_data.treat_csv(dim[0], 17,
                                                                                   "clean_PV_GIS_2018_SARAH2.csv")
# consumption_norm, consumption = import_data.data_cons_AutoCalSOl()
# production_norm, production = import_data.data_prod_AutoCalSol(dimPV=dim[0], dimPVmax=17)
# manager.add_data_prod(data_prod=production, data_prod_norm=production_norm)
# manager.add_data_cons(data_cons=consumption, data_cons_norm=consumption_norm)
data = [consumption, consumption_norm, production, production_norm]
env = gym.make("MicrogridControlGym-v0", dim=dim, data=data)
manager.data = data
print(manager.data)
env, state_dim, num_action = utils.make_env("MicrogridControlGym-v0", manager)
print('state dim console : ', state_dim)
writer = None
device = "cpu"
BCQ_threshold = 0.3
parameters = regular_parameters
policy = discrete_BCQ(
    False,
    num_action,
    state_dim,
    device,
    BCQ_threshold,
    parameters["discount"],
    parameters["optimizer"],
    parameters["optimizer_parameters"],
    parameters["polyak_target_update"],
    parameters["target_update_freq"],
    parameters["tau"],
    0,
    0,
    1,
    0,
    writer,
    parameters['train_freq']
)

policy.load(f"./Result/policy_to_load/MicrogridControlGym-v0_{manager._create_hashkey()}")

list_of_actions = np.array([])
rewards = np.array([])
obs = env.reset()
states = []
is_done = False
while not is_done:
    action = policy.select_action(np.array(obs))
    states = np.append(states, obs)
    obs, reward, is_done, info = env.step(action)
    rewards = np.append(rewards, reward)
    list_of_actions = np.append(list_of_actions, action)
tau_autoconsBCQ21 = []
tau_autoprodBCQ21 = []
tab = env.render_to_file()
grp = tab.groupby(tab.index.month)
action_charge = []
action_decharge = []
action_R = []
prod = []
list_of_actions = np.append(list_of_actions, 3)
tab['list_of_actions'] = list_of_actions
for i in range(len(grp)):
    prod.append(sum(tab['PV production'][grp.groups[i + 1]]))
    tau_autoprodBCQ21.append(
        1 - (sum(tab['Energy Bought'][grp.groups[i + 1]]) / sum(tab["Consumption"][grp.groups[i + 1]])))
    tau_autoconsBCQ21.append(
        1 - (sum(tab['Energy Sold'][grp.groups[i + 1]]) / sum(tab["PV production"][grp.groups[i + 1]])))
    action_charge.append(len(np.where(tab['list_of_actions'][grp.groups[i + 1]] == 2)[0]))
    action_decharge.append(len(np.where(tab['list_of_actions'][grp.groups[i + 1]] == 0)[0]))
    action_R.append(len(np.where(tab['list_of_actions'][grp.groups[i + 1]] == 1)[0]))
score = np.sum(rewards)
manager._create_hashkey()


act, con, pro, E_H2, indic = rule_based_actions(manager.dim, [tab['Consumption'],tab['Consumption'],tab['PV production'],tab['PV production']],0)

cumul_perte_agent = [0]
cumul_perte_rule = [0]
for i in range(len(tab['Energy Bought'])-1):
    cumul_perte_agent.append(cumul_perte_agent[-1]+tab['Energy Bought'][i])
    cumul_perte_rule.append(cumul_perte_rule[-1]+indic[i])
    
tickos = []
for i in np.linspace(1, len(tab), 11).astype(int) - 1:
    tickos.append(tab.index[i].month)

fig, ax1 = plt.subplots()

color = 'tab:red'
ax1.set_xlabel("Mois de l'année")
ax1.set_ylabel("Quantité d'hydrogène stocké (Wh)", color=color)
x=np.linspace(0, len(tab), len(tab + 1))
ax1.plot(x, cumul_perte_agent, color, x, cumul_perte_rule, 'tab:green')
ax1.tick_params(axis='y', labelcolor=color)

# ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis

# color = 'tab:blue'
# ax2.set_ylabel("Production d'électricité par panneaux PV (Wh)", color=color)  # we already handled the x-label with ax1
# xnew = np.linspace(x.min(), x.max(), 300) 
# spl = make_interp_spline(x, tab["PV production"], k=3)
# power_smooth = spl(xnew)
# ax2.plot(xnew, power_smooth, color=color)
# ax2.tick_params(axis='y', labelcolor=color)
plt.title("Quantité d'hydrogène stocké au long d'une année de simulation après apprentissage sur un micro-réseau dimensionné avec 5kWc de panneaux PV et 5kWh de capacité de batterie")
plt.xticks(np.linspace(0, len(tab), 11), tickos)
fig.tight_layout()  # otherwise the right y-label is slightly clipped
plt.show()
