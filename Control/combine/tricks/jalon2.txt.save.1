from discrete_BCQ.main import main_BCQ
from microgrid.envs.import_data import Import_data
from buffer_tools.hash_manager import Dim_manager
import pandas as pd
import numpy as np
from os.path import exists
import glob
import torch


if __name__ == "__main__":
    dim_num_iteration=5
    dim_boundaries = {'PV': {'low': 0, 'high': 12}, 'batt': {'low': 0, 'high': 15}}
    distance_euclidienne = 3
    nb_voisins = 1
    manager = Dim_manager(distance=distance_euclidienne,nb_voisins=nb_voisins)
    import_data = Import_data(mode="train")
    consumption = import_data.consumption()
    consumption_norm = import_data._consumption_norm()
    manager.add_data_cons(data_cons=consumption, data_cons_norm=consumption_norm)
    ### Arguments ne variant pas pour le main BCQ:
    env = "MicrogridControlGym-v0"
    seed = 1
    max_timestep = 1e6  # Nombre d'iteration si generate buffer ou train_behavioral. C'est le nombre de tuples utilisés


    for i in range(dim_num_iteration):
        print(f"itération {i} de dimensionnement")
        cheat_dim_list = [np.array([8.0,9.0]),np.array([11.0,11.0]),np.array([11.0, 10.0]),np.array([12.0,12.0]),np.array([11.0,9.0])] #Ajouté uniquement dans un but d'analyse de l'algo au début (on force le nb de voisin a etre petit)
        # dim = np.array([float(np.random.randint(dim_boundaries['PV']['low'], dim_boundaries['PV']['high'])),
        #                 float(np.random.randint(dim_boundaries['batt']['low'], dim_boundaries['batt']['high']))])
        dim = cheat_dim_list[i]
        manager._dim(dim.tolist())
        manager.choose_parents()

#modifs effectives

	manager.add_to_dicto()
            production_norm = import_data._production_norm(PV=dim[0])
            production = import_data.production()
            manager.add_data_prod(data_prod=production, data_prod_norm=production_norm
